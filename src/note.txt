매개값 argument value

메서드를 호출할 때 전달하는 값

public int sum(int a, int b) {
    return a + b;
}
위의 코드에서 a, b가 매개값이다
/
/
super

super 필요할 경우:
자식 클래스와 부모 클래스에 같은 이름의 필드가 있을 때,
부모 클래스의 필드에 접근하고 싶다면 super를 사용해야 합니다.

super 필요하지 않을 경우:
자식 클래스의 필드에 접근할 때는 this를 사용하거나
super를 사용하지 않고도 접근 가능합니다.
/
/
override

개념
부모 클래스에서 정의된 메서드를
자식 클래스에서 같은 이름, 같은 매개변수 목록으로
재정의하는 것을 의미합니다.

필요성
다형성(Polymorphism):
같은 메서드 이름이지만 자식 클래스에서 다른 방식으로 동작하도록 할 수 있습니다.
이를 통해 다양한 객체를 동일한 인터페이스로 처리할 수 있게 해줍니다.

유지 보수 용이:
부모 클래스에서 메서드를 오버라이드하면,
자식 클래스에서 필요할 때만 특정 동작을 변경할 수 있습니다.
이로 인해 코드의 일관성을 유지하면서도 각 클래스의 특성에 맞게 동작을 정의할 수 있습니다.

코드 재사용성:
부모 클래스의 메서드를 재정의함으로써,
기본 동작을 유지하면서 필요한 부분만 수정할 수 있습니다.
전체 코드를 다시 작성할 필요 없이 기존 기능을 확장하거나 변경할 수 있습니다.

부모 클래스의 기능 확장:
기본 기능을 갖춘 부모 클래스가 있을 때,
자식 클래스에서 그 기능을 오버라이드하여 새로운 기능이나 동작을 추가할 수 있습니다
이렇게 하면 부모 클래스의 기능을 확장하면서도 기본 동작은 유지할 수 있습니다.

코드 작성과의 차이점
유연성:
오버라이드를 사용하면 클래스 간의 관계가 더 명확해지고,
객체 지향의 원칙에 따라 코드를 구성할 수 있습니다.
반면, 코드를 재작성하면 중복된 코드가 생기고, 이로 인해 유지보수가 어려워질 수 있습니다.

중복 제거:
메서드를 오버라이드하면 부모 클래스의 코드를 재사용하게 되므로 중복을 줄일 수 있습니다.
코드가 여러 곳에 중복되어 있다면, 한 곳에서 변경해야 할 경우 모든 위치에서 수정을 해야 할 수도 있습니다.

구조적 개선:
오버라이드를 통해 객체 지향적 설계를 보다 깔끔하게 유지할 수 있습니다.
즉, 클래스와 메서드 간의 관계를 명확히 하여 프로그램 구조를 개선하는 데 도움이 됩니다.
/
/
부모 클래스가 자식 클래스를 인스턴스화할 수 없다:
new A()는 A의 인스턴스를 생성하는 것이며, 이 인스턴스는 B의 인스턴스가 아닙니다.
따라서 A 타입의 객체를 B 타입으로 캐스팅하려고 하면 문제가 발생합니다.

자식이 부모를 정의할 수 없다:
자식 클래스(B)는 부모 클래스(A)의 모든 속성과 메서드를 상속받지만,
부모 클래스의 객체를 자식 클래스의 타입으로 간주할 수는 없습니다.

부모는 자식의 특성을 가지고 있지만, 자식이 부모의 특성을 갖는 것은 아닙니다.