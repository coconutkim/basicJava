매개값 argument value

메서드를 호출할 때 전달하는 값

public int sum(int a, int b) {
    return a + b;
}
위의 코드에서 a, b가 매개값이다

--------------------------------------------------------------

super

super 필요할 경우:
같은 이름의 필드가 자식 클래스와 부모 클래스에 둘 다 있는 경우,
부모 클래스의 필드에 명시적으로 접근하려면 super를 사용해야 합니다.

super 필요하지 않을 경우:
자식 클래스의 필드에 접근할 때는 this를 사용하거나
super를 사용하지 않고도 접근 가능합니다.

---------------------------------------------------------------

override

개념
부모 클래스에서 정의된 메서드를
자식 클래스에서 같은 이름, 같은 매개변수 목록으로
재정의하는 것을 의미합니다.

필요성
모든 메소드가 자식 클래스에 맞게 설계되어 있는게 이상적임
그러나 어떤 메소드는 자식 클래스가 사용하기에 적합하지 않다
이럴 때 자식 클래스에서 재정의해서 사용한다

다형성(Polymorphism):
같은 메서드 이름이지만 자식 클래스에서 다른 방식으로 동작하도록 할 수 있습니다.
이를 통해 다양한 객체를 동일한 인터페이스로 처리할 수 있게 해줍니다.

유지 보수 용이:
부모 클래스에서 메서드를 오버라이드하면,
자식 클래스에서 필요할 때만 특정 동작을 변경할 수 있습니다.
이로 인해 코드의 일관성을 유지하면서도 각 클래스의 특성에 맞게 동작을 정의할 수 있습니다.

코드 재사용성:
부모 클래스의 메서드를 재정의함으로써,
기본 동작을 유지하면서 필요한 부분만 수정할 수 있습니다.
전체 코드를 다시 작성할 필요 없이 기존 기능을 확장하거나 변경할 수 있습니다.

부모 클래스의 기능 확장:
기본 기능을 갖춘 부모 클래스가 있을 때,
자식 클래스에서 그 기능을 오버라이드하여 새로운 기능이나 동작을 추가할 수 있습니다
이렇게 하면 부모 클래스의 기능을 확장하면서도 기본 동작은 유지할 수 있습니다.

코드 작성과의 차이점
유연성:
오버라이드를 사용하면 클래스 간의 관계가 더 명확해지고,
객체 지향의 원칙에 따라 코드를 구성할 수 있습니다.
반면, 코드를 재작성하면 중복된 코드가 생기고, 이로 인해 유지보수가 어려워질 수 있습니다.

중복 제거:
메서드를 오버라이드하면 부모 클래스의 코드를 재사용하게 되므로 중복을 줄일 수 있습니다.
코드가 여러 곳에 중복되어 있다면, 한 곳에서 변경해야 할 경우 모든 위치에서 수정을 해야 할 수도 있습니다.

구조적 개선:
오버라이드를 통해 객체 지향적 설계를 보다 깔끔하게 유지할 수 있습니다.
즉, 클래스와 메서드 간의 관계를 명확히 하여 프로그램 구조를 개선하는 데 도움이 됩니다.

-----------------------------------------------------------------------

부모 클래스가 자식 클래스를 인스턴스화할 수 없다:
new A()는 A의 인스턴스를 생성하는 것이며, 이 인스턴스는 B의 인스턴스가 아닙니다.
따라서 A 타입의 객체를 B 타입으로 캐스팅하려고 하면 문제가 발생합니다.

자식이 부모를 정의할 수 없다:
자식 클래스(B)는 부모 클래스(A)의 모든 속성과 메서드를 상속받지만,
부모 클래스의 객체를 자식 클래스의 타입으로 간주할 수는 없습니다.

부모는 자식의 특성을 가지고 있지만, 자식이 부모의 특성을 갖는 것은 아닙니다.

---------------------------------------------------------------

인터페이스

[ public static final ] 타입 상수명 = 값;
선언된 필드는 모두 위의 특성을 갖는다
생략하더라도 자동적으로 컴파일 과정에서 붙게 된다

상수명
대문자로 작성
서로 다른 단어로 구성되어 있으면 언더바로 연결하는 것이 관례

장점
다중 상속 지원:
클래스는 단일 상속만 가능하지만,
인터페이스는 여러 개를 구현할 수 있습니다.
이를 통해 다양한 기능을 독립적으로 정의한 후,
하나의 클래스에서 여러 기능을 결합할 수 있습니다.

유연한 설계:
인터페이스를 사용하면 코드의 의존성을 낮출 수 있습니다.
특정 클래스에 의존하지 않고, 인터페이스에 의존하면,
나중에 다른 구현체로 쉽게 교체할 수 있어 유지보수와 확장성이 좋아집니다.

표준화된 행동 정의:
인터페이스는 클래스들이 반드시 구현해야 하는 메서드의 규격을 강제할 수 있습니다.
이를 통해 다양한 클래스가 동일한 메서드 시그니처로 구현될 수 있어
일관성을 유지할 수 있습니다.

"객체가 다르고 동작이 같으면 인터페이스를 활용한다"

----------------------------------------------

static

보통은 할당과 해제를 자유롭게 한다
반면에 static은 항상 고정되어 있다

---------------------------------

private method

용도
디폴트와 정적 메소드들의 중복 코드를 줄이기 위함